<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Simulador Sutura - Física Real</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: sans-serif; }
        #info {
            position: absolute; top: 10px; width: 100%; text-align: center;
            color: #00d4ff; pointer-events: none; z-index: 10; font-weight: bold; text-shadow: 1px 1px 2px #000;
        }
        #btn-container { 
            position: absolute; bottom: 30px; left: 50%; 
            transform: translateX(-50%); z-index: 20; 
        }
        button { 
            padding: 15px 40px; font-size: 18px; cursor: pointer; font-weight: bold;
            background: #0066cc; color: #fff; border: none; border-radius: 50px;
            box-shadow: 0 0 15px rgba(0, 102, 204, 0.5);
        }
    </style>
</head>
<body>

    <div id="info">SISTEMA DE SUTURA VETORIAL</div>
    <div id="btn-container">
        <button onclick="startProcedure()">REALIZAR PONTO</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        let scene, camera, renderer;
        let skinMesh;
        
        // Grupos "Riggados"
        let needleHolderGroup, scissorsGroup; 
        // Partes móveis para animar
        let needlePivot, scissorsBlade1, scissorsBlade2; 
        
        // Variáveis do Fio Dinâmico
        let activeThreadMesh = null;
        let threadPoints = [];
        let isSewing = false;

        init();
        animate();

        function init() {
            // 1. Setup Básico
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111111);
            
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 15, 10);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Otimização para tablet
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            // Luzes
            scene.add(new THREE.AmbientLight(0xffffff, 0.6));
            const spot = new THREE.SpotLight(0xffffff, 1.2);
            spot.position.set(5, 20, 5);
            spot.castShadow = true;
            scene.add(spot);

            // 2. Pele (Com corte no meio)
            // Usamos textura processual simples para garantir que roda
            const skinGeo = new THREE.PlaneGeometry(10, 10);
            const skinMat = new THREE.MeshStandardMaterial({ color: 0xeebb99, roughness: 0.8 });
            skinMesh = new THREE.Mesh(skinGeo, skinMat);
            skinMesh.rotation.x = -Math.PI / 2;
            skinMesh.receiveShadow = true;
            scene.add(skinMesh);
            
            // Marca do corte (Visual)
            const cut = new THREE.Mesh(new THREE.PlaneGeometry(0.2, 6), new THREE.MeshBasicMaterial({color: 0x330000}));
            cut.rotation.x = -Math.PI/2;
            cut.position.y = 0.01;
            scene.add(cut);

            // 3. Criar Instrumentos Riggados via Código
            createRiggedNeedleHolder();
            createRiggedScissors();
        }

        // --- SISTEMA DE RIGGING (ESQUELETO) VIA CÓDIGO ---
        
        function createRiggedNeedleHolder() {
            needleHolderGroup = new THREE.Group();

            // PIVÔ PRINCIPAL: Este é o segredo.
            // O porta-agulhas não gira pelo cabo, ele gira pelo centro da curvatura da agulha.
            needlePivot = new THREE.Group();
            needleHolderGroup.add(needlePivot);

            const metalMat = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, metalness: 0.9, roughness: 0.2 });

            // 1. A Agulha (Toro parcial)
            // Raio 1.5. O centro do Pivot deve estar a 1.5 de distância
            const needleRadius = 1.5;
            const needleGeo = new THREE.TorusGeometry(needleRadius, 0.05, 8, 32, Math.PI); 
            const needle = new THREE.Mesh(needleGeo, metalMat);
            // Posiciona a agulha para que seu centro geométrico fique no needlePivot (0,0,0)
            needle.rotation.z = Math.PI/2; 
            needle.position.set(0, 0, 0); 
            needlePivot.add(needle);

            // 2. O Porta-Agulhas (Segurando a agulha)
            const holderTip = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.5, 0.2), metalMat);
            // Posiciona a ponta segurando a agulha (no raio 1.5)
            holderTip.position.set(0, needleRadius, 0); 
            needlePivot.add(holderTip);

            const holderShaft = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 5), metalMat);
            holderShaft.position.set(0, needleRadius + 2.5, 0);
            needlePivot.add(holderShaft);

            // Posiciona o grupo inteiro acima da pele
            needleHolderGroup.position.set(0, 2, 0);
            scene.add(needleHolderGroup);
        }

        function createRiggedScissors() {
            scissorsGroup = new THREE.Group();
            const metalMat = new THREE.MeshStandardMaterial({ color: 0xcccccc, metalness: 0.8 });

            // Pivô central da tesoura
            const pivot = new THREE.Group();
            scissorsGroup.add(pivot);

            // Lâmina 1 (Móvel)
            scissorsBlade1 = new THREE.Mesh(new THREE.BoxGeometry(0.15, 2, 0.05), metalMat);
            scissorsBlade1.position.y = -1; // Desloca para o pivô ficar no topo da lâmina
            // Wrapper para girar pelo topo
            const b1Group = new THREE.Group();
            b1Group.add(scissorsBlade1);
            pivot.add(b1Group);
            scissorsBlade1 = b1Group; // Referência para animar

            // Lâmina 2 (Móvel inversa)
            scissorsBlade2 = new THREE.Mesh(new THREE.BoxGeometry(0.15, 2, 0.05), metalMat);
            scissorsBlade2.position.y = -1;
            const b2Group = new THREE.Group();
            b2Group.add(scissorsBlade2);
            pivot.add(b2Group);
            scissorsBlade2 = b2Group;

            // Cabo
            const handle = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 3), metalMat);
            handle.position.y = 1.5;
            pivot.add(handle);

            scissorsGroup.position.set(2, 2, 0);
            scissorsGroup.rotation.z = -Math.PI / 4; // Inclinação de corte
            scissorsGroup.visible = false;
            scene.add(scissorsGroup);
        }

        // --- MOTOR DE ANIMAÇÃO PROCEDURAL ---

        function startProcedure() {
            if(isSewing) return;
            isSewing = true;
            
            // Reseta posições
            needleHolderGroup.position.set(2, 2, 1); // Posição inicial (mão direita)
            needleHolderGroup.rotation.set(0, 0, 0);
            needlePivot.rotation.x = -Math.PI/2; // Agulha preparada

            // Limpa fio antigo
            if(activeThreadMesh) { scene.remove(activeThreadMesh); activeThreadMesh = null; }
            threadPoints = [];

            // INICIA A CRONOLOGIA (Sequência de Eventos)
            
            // 1. Aproximação
            animateVector(needleHolderGroup.position, {x: 0, y: 1.5, z: 0}, 1000, () => {
                
                // 2. Rotação de Entrada (Munheca) + Geração de Fio
                performSutureRotation();
            });
        }

        function performSutureRotation() {
            const duration = 2000; // 2 segundos para passar a agulha
            const startTime = Date.now();
            const startRot = -Math.PI / 4; // Começa inclinado pra trás
            const endRot = Math.PI * 1.2;  // Gira quase completo
            
            needlePivot.rotation.x = startRot;

            const loop = setInterval(() => {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // A. ANIMAÇÃO DA AGULHA (Rotação no Pivô)
                // Isso faz a agulha entrar curva e sair curva perfeitamente
                needlePivot.rotation.x = startRot + (endRot - startRot) * progress;

                // B. GERAÇÃO DO RASTRO DO FIO
                // Calculamos onde está o "fundo" da agulha no mundo 3D agora
                // A agulha tem raio 1.5. O fundo está no ângulo oposto da ponta.
                const needleBottom = new THREE.Vector3(0, -1.5, 0); 
                
                // Aplica todas as rotações do pai ao ponto
                needleBottom.applyMatrix4(needlePivot.matrixWorld);
                
                // Adiciona ponto ao rastro se moveu o suficiente
                if (threadPoints.length === 0 || needleBottom.distanceTo(threadPoints[threadPoints.length-1]) > 0.05) {
                    threadPoints.push(needleBottom.clone());
                    updateThreadVisuals();
                }

                if (progress >= 1) {
                    clearInterval(loop);
                    // 3. Tesoura entra
                    performCut();
                }
            }, 16);
        }

        function updateThreadVisuals() {
            if (threadPoints.length < 2) return;

            // Remove malha antiga
            if (activeThreadMesh) scene.remove(activeThreadMesh);

            // Cria curva suave através dos pontos
            const curve = new THREE.CatmullRomCurve3(threadPoints);
            
            // Cria tubo dinâmico (Fio Azul Nylon 3-0)
            const geometry = new THREE.TubeGeometry(curve, threadPoints.length * 2, 0.04, 8, false);
            const material = new THREE.MeshPhongMaterial({ color: 0x0055ff });
            
            activeThreadMesh = new THREE.Mesh(geometry, material);
            scene.add(activeThreadMesh);
        }

        function performCut() {
            // Posiciona Tesoura
            scissorsGroup.visible = true;
            scissorsGroup.position.set(0, 1.5, 0);
            
            // Abre Tesoura
            scissorsBlade1.rotation.z = 0.5;
            scissorsBlade2.rotation.z = -0.5;

            // Animação de Corte (Fecha Lâminas)
            let cutProgress = 0;
            const cutAnim = setInterval(() => {
                cutProgress += 0.1;
                
                // Fecha
                scissorsBlade1.rotation.z = 0.5 * (1 - cutProgress);
                scissorsBlade2.rotation.z = -0.5 * (1 - cutProgress);

                if (cutProgress >= 1) {
                    clearInterval(cutAnim);
                    
                    // Retira Tesoura e Agulha
                    setTimeout(() => {
                        scissorsGroup.visible = false;
                        animateVector(needleHolderGroup.position, {x: 0, y: 5, z: 0}, 1000, () => {
                            isSewing = false;
                        });
                    }, 500);
                }
            }, 30);
        }

        // Função utilitária para mover objetos suavemente
        function animateVector(vector, target, duration, callback) {
            const start = vector.clone();
            const startTime = Date.now();
            
            const timer = setInterval(() => {
                const elapsed = Date.now() - startTime;
                const p = Math.min(elapsed / duration, 1);
                // Easing suave (SmoothStep)
                const smoothP = p * p * (3 - 2 * p);
                
                vector.x = start.x + (target.x - start.x) * smoothP;
                vector.y = start.y + (target.y - start.y) * smoothP;
                vector.z = start.z + (target.z - start.z) * smoothP;

                if (p >= 1) {
                    clearInterval(timer);
                    if(callback) callback();
                }
            }, 16);
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
