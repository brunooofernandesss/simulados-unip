<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Simulador Sutura Pro - Protótipo</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: sans-serif; background-color: #0a0a0a; }
        #info {
            position: absolute; top: 10px; width: 100%; text-align: center;
            color: #fff; pointer-events: none; z-index: 10;
            text-shadow: 2px 2px 4px #000;
        }
        #info h3 { margin: 5px 0; font-weight: 300; letter-spacing: 2px; }
        #info p { font-size: 14px; color: #ccc; }
        #gui-container { position: absolute; top: 10px; right: 10px; z-index: 30; }
        #reset-btn-container { position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%); z-index: 30; }
        button { 
            padding: 15px 30px; font-size: 16px; cursor: pointer; font-weight: bold;
            background: linear-gradient(45deg, #007bff, #00d4ff); color: #fff; border: none; border-radius: 50px;
            box-shadow: 0 10px 20px rgba(0, 123, 255, 0.3); transition: all 0.3s ease;
        }
        button:hover { transform: translateX(-50%) translateY(-3px); box-shadow: 0 15px 25px rgba(0, 123, 255, 0.5); }
        button:active { transform: translateX(-50%) translateY(1px); }
    </style>
</head>
<body>
    <div id="info">
        <h3>SIMULADOR CLÍNICO V.04</h3>
        <p>Ambiente estéril. Use o porta-agulhas para realizar pontos simples.</p>
        <p style="font-size: 18px; margin-top: 10px;">Pontos Realizados: <span style="color:#00d4ff" id="stitch-count">0</span></p>
    </div>
    
    <div id="gui-container"></div>
    
    <div id="reset-btn-container">
        <button onclick="resetSimulation()">NOVO PROCEDIMENTO</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lil-gui@0.17.0/dist/lil-gui.umd.min.js"></script>

    <script>
        let scene, camera, renderer, raycaster, mouse;
        let skinMesh, toolGroup;
        let stitchesObjects = [];
        let startPoint = null;
        let stitchCount = 0;
        let originalPositions;
        let isAnimating = false;

        const settings = {
            offsetX: 0.0, offsetY: 0.0, zoomLevel: 12, normalScale: 0.5
        };
        let gui;

        const manager = new THREE.LoadingManager();
        manager.onLoad = function ( ) { init(); initGUI(); animate(); };

        const textureLoader = new THREE.TextureLoader(manager);
        // Usando suas imagens (certifique-se que estão na pasta)
        const colorTexture = textureLoader.load('pele_cor.jpg', (t) => {
            t.minFilter = THREE.LinearFilter; t.wrapS = t.wrapT = THREE.ClampToEdgeWrapping; t.encoding = THREE.sRGBEncoding; 
        }); 
        const normalTexture = textureLoader.load('pele_normal.jpg', (t) => { t.wrapS = t.wrapT = THREE.ClampToEdgeWrapping; });

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x0a0a0a, 0.02); // Neblina para profundidade

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            updateCameraPosition(); 

            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setPixelRatio(window.devicePixelRatio); 
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.toneMapping = THREE.ACESFilmicToneMapping; 
            renderer.toneMappingExposure = 1.2;
            document.body.appendChild(renderer.domElement);

            // ILUMINAÇÃO DE CENTRO CIRÚRGICO
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4); scene.add(ambientLight);
            
            const mainLight = new THREE.SpotLight(0xffeedd, 1.5);
            mainLight.position.set(5, 15, 2);
            mainLight.angle = 0.5;
            mainLight.penumbra = 0.5;
            mainLight.castShadow = true;
            mainLight.shadow.mapSize.set(2048, 2048);
            scene.add(mainLight);

            const rimLight = new THREE.PointLight(0x00d4ff, 0.5); // Luz de recorte azulada
            rimLight.position.set(-10, 5, -10);
            scene.add(rimLight);

            // MESA CIRÚRGICA (Metal)
            const tableGeo = new THREE.PlaneGeometry(30, 30);
            const tableMat = new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.8, roughness: 0.2 });
            const table = new THREE.Mesh(tableGeo, tableMat);
            table.rotation.x = -Math.PI / 2;
            table.position.y = -0.1;
            table.receiveShadow = true;
            scene.add(table);

            // PELE DE SILICONE
            const skinGeometry = new THREE.PlaneGeometry(10, 10, 150, 150); 
            originalPositions = Float32Array.from(skinGeometry.attributes.position.array);
            const skinMaterial = new THREE.MeshStandardMaterial({ 
                map: colorTexture, normalMap: normalTexture, normalScale: new THREE.Vector2(0.5, 0.5),
                roughness: 0.5, metalness: 0.0, side: THREE.DoubleSide
            });
            skinMesh = new THREE.Mesh(skinGeometry, skinMaterial);
            skinMesh.rotation.x = -Math.PI / 2;
            skinMesh.receiveShadow = true;
            skinMesh.geometry.attributes.position.setUsage(THREE.DynamicDrawUsage);
            scene.add(skinMesh);

            // --- CRIAÇÃO DO INSTRUMENTO (PORTA-AGULHAS) ---
            createSurgicalTool();

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            window.addEventListener('resize', onWindowResize, false);
            window.addEventListener('pointerup', onMouseClick, false); 
            window.addEventListener('pointermove', onMouseMove, false);
        }

        // Cria o grupo que contém a agulha e o "porta-agulhas" (arte de programador)
        function createSurgicalTool() {
            toolGroup = new THREE.Group();

            // A Agulha curva
            const needleGeo = new THREE.TorusGeometry(0.4, 0.02, 8, 20, Math.PI * 1.2);
            const needleMat = new THREE.MeshStandardMaterial({ color: 0xc0c0c0, metalness: 1.0, roughness: 0.1 });
            const needle = new THREE.Mesh(needleGeo, needleMat);
            needle.rotation.x = Math.PI / 2; needle.rotation.z = Math.PI / 4; needle.position.set(0, -0.4, 0);
            toolGroup.add(needle);

            // O Porta-Agulhas (Representação simples com cilindros metálicos)
            const holderMat = new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.9, roughness: 0.2 });
            const jaw1 = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.03, 2), holderMat);
            jaw1.rotation.x = Math.PI / 2; jaw1.rotation.z = -0.1; jaw1.position.set(0.1, 0.5, 0);
            toolGroup.add(jaw1);
            const jaw2 = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.03, 2), holderMat);
            jaw2.rotation.x = Math.PI / 2; jaw2.rotation.z = 0.1; jaw2.position.set(-0.1, 0.5, 0);
            toolGroup.add(jaw2);

            toolGroup.position.set(0, 5, 0);
            toolGroup.castShadow = true;
            scene.add(toolGroup);
        }

        function initGUI() {
            gui = new lil.GUI({ container: document.getElementById('gui-container'), title: 'Ajustes Clínicos' });
            gui.add(settings, 'offsetX', -0.5, 0.5, 0.001).name('Centro X').onChange(updateTextureOffset);
            gui.add(settings, 'offsetY', -0.5, 0.5, 0.001).name('Centro Y').onChange(updateTextureOffset);
            gui.add(settings, 'zoomLevel', 5, 20, 0.5).name('Zoom Lupa').onChange(updateCameraPosition);
            gui.add(settings, 'normalScale', 0.0, 2.0, 0.1).name('Textura Silicone').onChange((v) => skinMesh.material.normalScale.set(v,v));
            updateTextureOffset();
        }

        function updateTextureOffset() { colorTexture.offset.set(settings.offsetX, settings.offsetY); normalTexture.offset.set(settings.offsetX, settings.offsetY); }
        function updateCameraPosition() { camera.position.set(0, settings.zoomLevel, settings.zoomLevel * 0.4); camera.lookAt(0, 0, 0); }

        function onMouseMove(event) {
            if(isAnimating) return; // Não move se estiver animando o ponto
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(skinMesh);
            if (intersects.length > 0) {
                const point = intersects[0].point;
                // O instrumento flutua sobre a pele, inclinado para parecer que uma mão segura
                toolGroup.position.set(point.x, point.y + 1.0, point.z + 0.5);
                toolGroup.rotation.x = -Math.PI / 6; // Inclinação
            }
        }

        function onMouseClick(event) {
            if (event.target.closest('.lil-gui') || event.target.tagName === 'BUTTON' || isAnimating) return;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(skinMesh);
            if (intersects.length > 0) {
                handleSutureLogic(intersects[0].point);
            }
        }

        function handleSutureLogic(point) {
            if (!startPoint) {
                startPoint = point;
                animateInstrumentAction(point, true); // Anima entrada
                createPunctureDot(point);
            } else {
                animateInstrumentAction(point, false, () => { // Anima saída e depois cria o fio
                    createThread3D(startPoint, point);
                    performSkinDeformation(startPoint, point);
                    startPoint = null;
                    stitchCount++;
                    document.getElementById('stitch-count').innerText = stitchCount;
                });
                 createPunctureDot(point);
            }
        }

        // Animação simples do instrumento "mergulhando" na pele
        function animateInstrumentAction(targetPos, isEntry, onComplete) {
            isAnimating = true;
            const startY = toolGroup.position.y;
            const targetY = targetPos.y + 0.2; // Mergulha até quase tocar
            let down = true;

            const interval = setInterval(() => {
                if(down) {
                    toolGroup.position.y -= 0.15;
                    toolGroup.position.x = targetPos.x; toolGroup.position.z = targetPos.z + 0.2;
                    if(toolGroup.position.y <= targetY) down = false;
                } else {
                    toolGroup.position.y += 0.15;
                    if(toolGroup.position.y >= startY) {
                        clearInterval(interval);
                        isAnimating = false;
                        if(onComplete) onComplete();
                    }
                }
            }, 16);
        }

        function performSkinDeformation(p1, p2) {
            const positions = skinMesh.geometry.attributes.position.array;
            const vertexCount = positions.length / 3;
            const influenceRadius = 1.2; const pullStrength = 0.7; 
            skinMesh.updateMatrixWorld();

            [p1, p2].forEach(stitchPoint => {
                let localPoint = stitchPoint.clone(); skinMesh.worldToLocal(localPoint);
                const side = localPoint.x < 0 ? 'left' : 'right';

                for (let i = 0; i < vertexCount; i++) {
                    const ix = i*3, iy = i*3+1, iz = i*3+2;
                    let vX = positions[ix], vY = positions[iy];
                    const dist = Math.sqrt(Math.pow(vX - localPoint.x, 2) + Math.pow(vY - localPoint.y, 2));

                    if (dist < influenceRadius) {
                        const move = Math.pow(1.0 - (dist/influenceRadius), 3) * pullStrength;
                        if (side === 'left' && vX < 0) positions[ix] = Math.min(-0.02, vX + move);
                        else if (side === 'right' && vX > 0) positions[ix] = Math.max(0.02, vX - move);
                        positions[iz] += move * 0.3; // Eversão
                    }
                }
            });
            skinMesh.geometry.attributes.position.needsUpdate = true;
            skinMesh.geometry.computeVertexNormals();
        }

        function createPunctureDot(point) {
            const dot = new THREE.Mesh(new THREE.SphereGeometry(0.04, 8, 8), new THREE.MeshBasicMaterial({ color: 0x1a0000 }));
            dot.position.copy(point); dot.position.y -= 0.01; 
            scene.add(dot); stitchesObjects.push(dot);
        }

        // --- NOVA FUNÇÃO DE FIO 3D (CORREÇÃO DO FIO SUMIDO) ---
        function createThread3D(p1, p2) {
            const mid = new THREE.Vector3().addVectors(p1, p2).multiplyScalar(0.5);
            mid.y += 0.15; // Arco tenso
            const curve = new THREE.QuadraticBezierCurve3(p1, mid, p2);
            
            // TubeGeometry cria um tubo 3D físico ao invés de uma linha fina
            const tubeGeo = new THREE.TubeGeometry(curve, 24, 0.03, 8, false); // 0.03 é a espessura do fio (Nylon 3-0)
            // Material azulado/escuro brilhante para parecer nylon monofilamentar
            const tubeMat = new THREE.MeshPhongMaterial({ color: 0x002255, specular: 0x111111, shininess: 100 });
            const thread = new THREE.Mesh(tubeGeo, tubeMat);
            thread.castShadow = true;
            scene.add(thread);
            stitchesObjects.push(thread);

            // "Nó" Falso (Representação visual do ponto final)
            const knotGeo = new THREE.SphereGeometry(0.07, 8, 8);
            const knot = new THREE.Mesh(knotGeo, tubeMat);
            knot.position.copy(p2);
            scene.add(knot);
            stitchesObjects.push(knot);
        }

        function resetSimulation() {
            for (let obj of stitchesObjects) { scene.remove(obj); }
            stitchesObjects = []; startPoint = null; stitchCount = 0;
            document.getElementById('stitch-count').innerText = 0;
            const positions = skinMesh.geometry.attributes.position.array;
            for (let i = 0; i < positions.length; i++) { positions[i] = originalPositions[i]; }
            skinMesh.geometry.attributes.position.needsUpdate = true;
            skinMesh.geometry.computeVertexNormals();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        function animate() { requestAnimationFrame(animate); renderer.render(scene, camera); }
    </script>
</body>
</html>
