<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Inspeção com Zoom Livre</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a1a; font-family: 'Segoe UI', sans-serif; }
        
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
            display: flex; flex-direction: column;
            z-index: 10;
        }

        #header {
            background: linear-gradient(180deg, rgba(0,0,0,0.9) 0%, transparent 100%);
            color: #fff; padding: 20px; text-align: center; pointer-events: auto;
            transition: opacity 0.5s;
        }
        
        #info-card {
            position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%);
            width: 90%; max-width: 400px;
            background: rgba(10, 10, 10, 0.9); 
            border-top: 3px solid #4CAF50;
            backdrop-filter: blur(10px);
            color: #fff; padding: 20px; border-radius: 8px;
            display: none; 
            box-shadow: 0 10px 50px rgba(0,0,0,1);
            pointer-events: auto;
            text-align: center;
        }

        #info-card h3 { margin: 0 0 10px 0; color: #4CAF50; font-size: 20px; text-transform: uppercase; letter-spacing: 1px; }
        #info-card p { font-size: 15px; color: #ddd; line-height: 1.6; margin: 0; }
        #info-card .hint { font-size: 11px; color: #666; margin-top: 15px; text-transform: uppercase; letter-spacing: 1px; }

        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #4CAF50; font-size: 18px; font-weight: bold;
            background: rgba(0,0,0,0.9); padding: 15px 30px; border-radius: 30px;
            z-index: 50;
        }
        
        /* Botão para voltar caso o usuário se perca no zoom */
        #back-btn {
            position: absolute; top: 20px; left: 20px; pointer-events: auto;
            background: rgba(255,255,255,0.1); color: white; border: 1px solid rgba(255,255,255,0.3);
            padding: 10px 15px; border-radius: 5px; cursor: pointer; display: none;
        }
    </style>
</head>
<body>

    <div id="loading">CARREGANDO...</div>

    <div id="ui-layer">
        <div id="header">
            <h2>MESA DE INSTRUMENTAÇÃO</h2>
            <p style="margin:0; font-size:12px; color:#888;">Toque para inspecionar</p>
        </div>
        
        <button id="back-btn" onclick="exitInspection()">⬅ VOLTAR</button>

        <div id="info-card">
            <h3 id="card-title">Título</h3>
            <p id="card-desc">Descrição.</p>
            <p class="hint">Use dois dedos para zoom</p>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        // --- ARQUIVO DE TESTE ---
        const testFile = {
            file: 'Leo Bone Holding Forceps 1 SharpFusion.glb', 
            name: 'Bone Holding Forceps',
            desc: 'Pinça de redução óssea utilizada para segurar fragmentos durante cirurgias ortopédicas. Note a cremalheira para travamento firme.'
        };

        const CAM_TABLE = new THREE.Vector3(0, 15, 10); 
        const CAM_INSPECT = new THREE.Vector3(0, 5, 8); 

        let scene, camera, renderer, controls, raycaster, mouse;
        let loadedObject = null;
        let tableMesh = null;
        
        let isInspecting = false; 
        
        // Variáveis de Transição Suave
        let isTransitioning = false;
        let targetPos = new THREE.Vector3();
        let targetLookAt = new THREE.Vector3();

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a);
            
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.copy(CAM_TABLE);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.outputEncoding = THREE.sRGBEncoding; 
            document.body.appendChild(renderer.domElement);

            // Controles Orbitais (O segredo do zoom com os dedos)
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; // Movimento suave
            controls.dampingFactor = 0.05;
            controls.enablePan = false; // Desativa arrastar para os lados (mantém centralizado)
            controls.enableZoom = true; // Ativa Zoom (Rodinha ou Pinça)
            controls.minDistance = 2; // Zoom máximo permitido
            controls.maxDistance = 20; // Zoom mínimo
            controls.maxPolarAngle = Math.PI / 2.1; 

            // Luzes
            const ambient = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambient);
            const mainLight = new THREE.SpotLight(0xffffff, 1.2);
            mainLight.position.set(5, 20, 10);
            mainLight.castShadow = true;
            scene.add(mainLight);
            const rimLight = new THREE.PointLight(0x4455ff, 0.5);
            rimLight.position.set(-5, 0, -5);
            scene.add(rimLight);

            // Mesa
            const tableGeo = new THREE.PlaneGeometry(40, 40);
            const tableMat = new THREE.MeshStandardMaterial({ color: 0x2e8b57, roughness: 0.9 });
            tableMesh = new THREE.Mesh(tableGeo, tableMat);
            tableMesh.rotation.x = -Math.PI / 2;
            tableMesh.receiveShadow = true;
            scene.add(tableMesh);

            loadModel();

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            window.addEventListener('resize', onResize);
            window.addEventListener('pointerup', onClick);
        }

        function loadModel() {
            const loader = new THREE.GLTFLoader();
            const path = './models/' + testFile.file;

            loader.load(path, function (gltf) {
                const model = gltf.scene;
                
                // Configuração Inicial
                model.rotation.x = -Math.PI / 2;
                
                // Escala
                const boxTemp = new THREE.Box3().setFromObject(model);
                const sizeTemp = new THREE.Vector3();
                boxTemp.getSize(sizeTemp);
                const maxDim = Math.max(sizeTemp.x, sizeTemp.y, sizeTemp.z);
                const scaleFactor = 6.0 / maxDim; 
                model.scale.set(scaleFactor, scaleFactor, scaleFactor);

                // Altura Automática
                model.updateMatrixWorld(true); 
                const boxFinal = new THREE.Box3().setFromObject(model);
                const bottomY = boxFinal.min.y;
                const liftHeight = -bottomY + 0.1;
                
                model.position.y = liftHeight;

                // Salva estados
                model.userData.baseY = liftHeight;
                model.userData.baseRotX = model.rotation.x;

                // Materiais
                model.traverse((child) => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                        child.material.metalness = 0.7;
                        child.material.roughness = 0.3;
                    }
                });

                scene.add(model);
                loadedObject = model;
                
                document.getElementById('loading').style.display = 'none';

            }, undefined, function (error) {
                console.error(error);
                document.getElementById('loading').innerText = "ERRO: Arquivo não encontrado.";
                document.getElementById('loading').style.color = "red";
            });
        }

        function onClick(event) {
            if(!loadedObject || isTransitioning) return;

            // Se já estiver inspecionando e clicar no fundo vazio (não no objeto), sai
            // Mas se estiver inspecionando e clicar no objeto, não faz nada (deixa dar zoom)
            
            // Lógica de Raycaster
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects([loadedObject], true);

            if (intersects.length > 0) {
                if (!isInspecting) enterInspection();
            } else {
                // Clicou no vazio
                if (isInspecting) exitInspection();
            }
        }

        function enterInspection() {
            isInspecting = true;
            isTransitioning = true; // Inicia transição automática

            // 1. Prepara a Cena
            tableMesh.visible = false;
            scene.background = new THREE.Color(0x050505);

            // 2. Centraliza o Objeto (Importante para o OrbitControls girar em torno dele)
            loadedObject.position.set(0, 0, 0);
            loadedObject.rotation.x = 0; 
            loadedObject.rotation.z = Math.PI / 6;

            // 3. Define onde a câmera VAI parar
            targetPos.copy(CAM_INSPECT);
            targetLookAt.set(0, 0, 0);

            // UI
            document.getElementById('info-card').style.display = 'block';
            document.getElementById('header').style.opacity = '0';
            document.getElementById('back-btn').style.display = 'block';
            document.getElementById('card-title').innerText = testFile.name;
            document.getElementById('card-desc').innerText = testFile.desc;
        }

        function exitInspection() {
            isInspecting = false;
            isTransitioning = true; // Inicia transição de volta

            // 1. Prepara a Cena
            tableMesh.visible = true;
            scene.background = new THREE.Color(0x1a1a1a);

            // 2. Devolve o objeto
            loadedObject.position.set(0, loadedObject.userData.baseY, 0);
            loadedObject.rotation.x = loadedObject.userData.baseRotX;
            loadedObject.rotation.z = 0;

            // 3. Define onde a câmera VAI parar
            targetPos.copy(CAM_TABLE);
            targetLookAt.set(0, 0, 0);

            // UI
            document.getElementById('info-card').style.display = 'none';
            document.getElementById('header').style.opacity = '1';
            document.getElementById('back-btn').style.display = 'none';
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            
            if (isTransitioning) {
                // --- FASE DE TRANSIÇÃO AUTOMÁTICA ---
                // Move a câmera sozinha até o ponto ideal
                
                // Lerp (interpolação) suave
                camera.position.lerp(targetPos, 0.1);
                controls.target.lerp(targetLookAt, 0.1);
                
                // Verifica se chegou perto o suficiente para soltar o controle
                if (camera.position.distanceTo(targetPos) < 0.1) {
                    isTransitioning = false; // LIBERA O CONTROLE PARA O USUÁRIO
                }
            } else {
                // --- FASE DE CONTROLE LIVRE ---
                // Aqui o OrbitControls reina absoluto (Zoom e Rotação funcionam)
                controls.update();
            }

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
