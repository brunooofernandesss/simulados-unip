<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Simulador Sutura - Versão Estável</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: sans-serif; background-color: #111; }
        
        #info {
            position: absolute; top: 10px; width: 100%; text-align: center;
            color: #fff; pointer-events: none; z-index: 10;
            text-shadow: 1px 1px 2px #000;
        }
        
        #status {
            color: #00d4ff; font-weight: bold; margin-top: 5px; font-size: 16px;
        }

        #gui-container { position: absolute; top: 10px; right: 10px; z-index: 20; }
        
        #btn-container { 
            position: absolute; bottom: 20px; left: 50%; 
            transform: translateX(-50%); z-index: 20; 
        }
        
        button { 
            padding: 12px 30px; font-size: 16px; cursor: pointer; font-weight: bold;
            background: #0066cc; color: #fff; border: none; border-radius: 5px;
        }
    </style>
</head>
<body>

    <div id="info">
        <h3>Treino de Sutura (Versão Leve)</h3>
        <div id="status">Toque para suturar</div>
    </div>
    
    <div id="gui-container"></div>
    
    <div id="btn-container">
        <button onclick="resetApp()">LIMPAR TUDO</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lil-gui@0.17.0/dist/lil-gui.umd.min.js"></script>

    <script>
        let scene, camera, renderer, raycaster, mouse;
        let skinMesh, toolGroup, scissorsGroup;
        let stitches = [];
        let startPoint = null;
        let isBusy = false; // Bloqueia cliques durante animação

        // Configurações
        const settings = {
            offsetX: 0.0,
            offsetY: 0.0,
            zoom: 12,
            speed: 1.0
        };

        const statusEl = document.getElementById('status');
        const SUTURE_COLOR = 0x0055ff; // Azul

        // Inicia tudo
        init();
        animate();

        function init() {
            // 1. Cena
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111111);
            scene.fog = new THREE.FogExp2(0x111111, 0.02);

            // 2. Câmera
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, settings.zoom, settings.zoom * 0.4);
            camera.lookAt(0, 0, 0);

            // 3. Renderizador
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio); // Importante para tablet
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            // 4. Luzes
            const ambient = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambient);

            const spot = new THREE.SpotLight(0xffffff, 1);
            spot.position.set(5, 15, 5);
            spot.castShadow = true;
            scene.add(spot);

            // 5. Texturas (Carregamento direto, sem loading screen para não travar)
            const loader = new THREE.TextureLoader();
            const texMap = loader.load('pele_cor.jpg', function(t) {
                t.minFilter = THREE.LinearFilter;
                t.wrapS = t.wrapT = THREE.ClampToEdgeWrapping;
            });
            const texNorm = loader.load('pele_normal.jpg');

            // 6. Pele
            const geo = new THREE.PlaneGeometry(10, 10, 100, 100);
            const mat = new THREE.MeshStandardMaterial({
                color: 0xffccaa, // Cor base se a textura falhar
                map: texMap,
                normalMap: texNorm,
                normalScale: new THREE.Vector2(0.5, 0.5),
                roughness: 0.6
            });
            skinMesh = new THREE.Mesh(geo, mat);
            skinMesh.rotation.x = -Math.PI / 2;
            skinMesh.receiveShadow = true;
            // Permite deformar a pele
            skinMesh.geometry.attributes.position.setUsage(THREE.DynamicDrawUsage);
            scene.add(skinMesh);

            // 7. Ferramentas (Simples Geometrias)
            createTools();

            // 8. Interação
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            window.addEventListener('resize', onResize);
            window.addEventListener('pointermove', onMove);
            window.addEventListener('pointerup', onClick);
            
            // GUI
            setupGUI(texMap, texNorm);
        }

        function createTools() {
            // GRUPO DO PORTA-AGULHAS
            toolGroup = new THREE.Group();
            
            // Agulha (Toro parcial)
            const needleGeo = new THREE.TorusGeometry(0.3, 0.02, 8, 20, 4);
            const metalMat = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, metalness: 0.8, roughness: 0.2 });
            const needle = new THREE.Mesh(needleGeo, metalMat);
            needle.rotation.x = Math.PI/2;
            needle.position.y = -0.3;
            toolGroup.add(needle);

            // Haste do instrumento (Cilindro simples)
            const stick = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 2), metalMat);
            stick.position.set(0, 1, 0); // Haste para cima
            toolGroup.add(stick);

            toolGroup.position.set(0, 2, 0);
            scene.add(toolGroup);

            // GRUPO DA TESOURA
            scissorsGroup = new THREE.Group();
            // Lâminas (Caixas)
            const blade1 = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.8, 0.02), metalMat);
            blade1.position.x = 0.05; blade1.rotation.z = 0.2;
            const blade2 = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.8, 0.02), metalMat);
            blade2.position.x = -0.05; blade2.rotation.z = -0.2;
            
            scissorsGroup.add(blade1);
            scissorsGroup.add(blade2);
            scissorsGroup.position.set(0, 2, 0);
            scissorsGroup.visible = false; // Começa escondida
            scene.add(scissorsGroup);
        }

        // --- LÓGICA DE INTERAÇÃO ---

        function onMove(e) {
            if(isBusy) return;
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const hits = raycaster.intersectObject(skinMesh);

            if(hits.length > 0) {
                const p = hits[0].point;
                // Ferramenta segue o mouse flutuando
                toolGroup.position.set(p.x, p.y + 0.8, p.z);
                toolGroup.lookAt(p);
            }
        }

        function onClick(e) {
            if(e.target.tagName === 'BUTTON' || e.target.closest('.lil-gui') || isBusy) return;

            raycaster.setFromCamera(mouse, camera);
            const hits = raycaster.intersectObject(skinMesh);

            if(hits.length > 0) {
                const p = hits[0].point;
                handleAction(p);
            }
        }

        function handleAction(point) {
            if(!startPoint) {
                // PRIMEIRO CLIQUE (ENTRADA)
                startPoint = point;
                statusEl.innerText = "Ponto de entrada marcado. Clique na saída.";
                
                // Animação rápida de "picada"
                animatePuncture(point);
                addMarker(point);
            } else {
                // SEGUNDO CLIQUE (SAÍDA + NÓ)
                statusEl.innerText = "Realizando sutura...";
                addMarker(point);
                
                animatePuncture(point, () => {
                    performSuture(startPoint, point);
                });
            }
        }

        // Animação simples de descer e subir a ferramenta
        function animatePuncture(pos, callback) {
            isBusy = true;
            let down = true;
            const startY = 0.8;
            const targetY = 0.1;

            const timer = setInterval(() => {
                toolGroup.position.x = pos.x; 
                toolGroup.position.z = pos.z;

                if(down) {
                    toolGroup.position.y -= 0.1 * settings.speed;
                    if(toolGroup.position.y <= targetY) down = false;
                } else {
                    toolGroup.position.y += 0.1 * settings.speed;
                    if(toolGroup.position.y >= startY) {
                        clearInterval(timer);
                        isBusy = false;
                        if(callback) callback();
                    }
                }
            }, 16);
        }

        // --- SEQUÊNCIA DO NÓ ---

        function performSuture(p1, p2) {
            isBusy = true;
            toolGroup.visible = false; // Esconde agulha
            
            const center = new THREE.Vector3().addVectors(p1, p2).multiplyScalar(0.5);
            center.y += 2;

            // 1. Cria o LOOP (Nó aberto)
            const loopGeo = new THREE.TorusGeometry(0.8, 0.05, 16, 32);
            const loopMat = new THREE.MeshPhongMaterial({ color: SUTURE_COLOR });
            const loop = new THREE.Mesh(loopGeo, loopMat);
            loop.position.copy(center);
            loop.rotation.x = Math.PI/2;
            scene.add(loop);

            // 2. Anima o aperto do nó
            let progress = 0;
            const anim = setInterval(() => {
                progress += 0.02 * settings.speed;
                
                // Nó desce e diminui
                loop.position.y = THREE.MathUtils.lerp(2, 0.1, progress);
                loop.scale.setScalar(THREE.MathUtils.lerp(1, 0.1, progress));

                if(progress >= 1) {
                    clearInterval(anim);
                    scene.remove(loop);
                    
                    // Cria o ponto final fixo
                    createFinalStitch(p1, p2);
                    
                    // Chama a tesoura
                    animateScissors(center, p1, p2);
                }
            }, 20);
        }

        function createFinalStitch(p1, p2) {
            // Tubo Curvo (Fio)
            const mid = new THREE.Vector3().addVectors(p1, p2).multiplyScalar(0.5);
            mid.y += 0.1;
            const curve = new THREE.QuadraticBezierCurve3(p1, mid, p2);
            const tube = new THREE.Mesh(
                new THREE.TubeGeometry(curve, 8, 0.03, 8, false),
                new THREE.MeshPhongMaterial({ color: SUTURE_COLOR })
            );
            scene.add(tube);
            stitches.push(tube);

            // Bolinha (Nó)
            const knot = new THREE.Mesh(
                new THREE.SphereGeometry(0.06),
                new THREE.MeshPhongMaterial({ color: SUTURE_COLOR })
            );
            knot.position.copy(mid);
            scene.add(knot);
            stitches.push(knot);
        }

        function animateScissors(pos, p1, p2) {
            statusEl.innerText = "Cortando fio...";
            scissorsGroup.visible = true;
            scissorsGroup.position.set(pos.x, 1.5, pos.z);

            let step = 0;
            const anim = setInterval(() => {
                step += 0.05 * settings.speed;
                
                if(step < 0.5) {
                    // Desce
                    scissorsGroup.position.y -= 0.1;
                } else if (step < 1.0) {
                    // Corta (Gira lâminas)
                    scissorsGroup.children[0].rotation.z = 0;
                    scissorsGroup.children[1].rotation.z = 0;
                } else {
                    // Sobe e termina
                    scissorsGroup.position.y += 0.1;
                    if(scissorsGroup.position.y > 2) {
                        clearInterval(anim);
                        scissorsGroup.visible = false;
                        // Reseta tesoura
                        scissorsGroup.children[0].rotation.z = 0.2;
                        scissorsGroup.children[1].rotation.z = -0.2;
                        
                        finishTurn(p1, p2);
                    }
                }
            }, 30);
        }

        function finishTurn(p1, p2) {
            toolGroup.visible = true;
            startPoint = null;
            isBusy = false;
            statusEl.innerText = "Sutura concluída. Próximo ponto.";
            
            // Deforma a pele (Aproximação)
            deformSkin(p1, p2);
        }

        function deformSkin(p1, p2) {
            const posAttr = skinMesh.geometry.attributes.position;
            const verts = posAttr.array;
            
            // Puxa vértices próximos
            skinMesh.updateMatrixWorld();
            [p1, p2].forEach(p => {
                // Converte posição mundial do clique para local da pele
                const localP = p.clone();
                skinMesh.worldToLocal(localP);
                
                for(let i=0; i < verts.length; i+=3) {
                    const dx = verts[i] - localP.x;
                    const dy = verts[i+1] - localP.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    
                    if(dist < 1.0) {
                        // Move vertices em direção ao centro X=0
                        const force = (1.0 - dist) * 0.05;
                        if(verts[i] < 0) verts[i] += force; // Esquerda vai pra direita
                        if(verts[i] > 0) verts[i] -= force; // Direita vai pra esquerda
                        verts[i+2] += force * 0.5; // Levanta um pouco (Z no local = Y no mundo)
                    }
                }
            });
            posAttr.needsUpdate = true;
            skinMesh.geometry.computeVertexNormals();
        }

        function addMarker(p) {
            const m = new THREE.Mesh(
                new THREE.SphereGeometry(0.02), 
                new THREE.MeshBasicMaterial({color: 0x000000})
            );
            m.position.copy(p);
            scene.add(m);
            stitches.push(m);
        }

        function setupGUI(tex1, tex2) {
            const gui = new lil.GUI({ container: document.getElementById('gui-container') });
            gui.add(settings, 'offsetX', -0.5, 0.5).onChange(v => {
                if(tex1) tex1.offset.x = v;
                if(tex2) tex2.offset.x = v;
            });
            gui.add(settings, 'offsetY', -0.5, 0.5).onChange(v => {
                if(tex1) tex1.offset.y = v;
                if(tex2) tex2.offset.y = v;
            });
            gui.add(settings, 'zoom', 5, 20).onChange(v => {
                camera.position.set(0, v, v * 0.4);
                camera.lookAt(0,0,0);
            });
            gui.add(settings, 'speed', 0.1, 2.0).name('Velocidade');
        }

        function resetApp() {
            location.reload();
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

    </script>
</body>
</html>
